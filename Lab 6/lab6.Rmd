---
title: Lab 6
author: Ansel George
output:
    pdf_document:
        latex_engine: xelatex
monofont: Ubuntu Mono
mainfont: Roboto
fontsize: 11pt
---

```{r, message=F}
library(Basingstoke)
library(igraph)
library(bipartite)
library(RColorBrewer)
library(vegan)
library(gtools)

library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(ggplot2)
library(reshape2)

set.seed(10)
```


# Problem 1

*What essential features of food webs does the random algorithm miss?*

Nestedness, modularity, trophic separation, etc.


# Problem 2

*Try to implement the cascade model by yourself.*


```{r}
makeCascadeModel <- function(S, C) {
  res <- matrix(0, ncol=S, nrow=S)
  possiblelinks <- which(upper.tri(res))

  # Compute the number of links necessary for the given connectance.
  nlinks <- length(possiblelinks) * S*2 / (S-1) * C
  rem <- nlinks - floor(nlinks)
  nlinks <- floor(nlinks) + 1*(rem > runif(1))

  links <- sample(possiblelinks, nlinks) # fails if nlinks > possiblelinks
  res[links] <- 1
  return(res)
}
```

```{r}
pop <- makeCascadeModel(10, .15)
pop
```

The implementation will produce an adjacency matrix that, if used to generate
many matrices, will produce a set of with expected connectance that converges
to the specified connectance. The implementation in Basingstoke, which is
arguably simpler (though it could be made more concise), produces higher
variance in connectance for smaller versus larger graphs.


# Problem 3 (optional)

Try to implement the niche model. This is a challenging function to write!!!
Guidelines: Follow the caption in Fig. 1 of Williams and Martinez (2000), and
take the beta value for the beta distribution to be (S-1)/2SC-1 (as in equation
10 in the Supp Info of Allesina et al. (Science, 2008)). You can also get some
inspiration from the function NicheModelLinks for the last step determining the
consumers. But do not copy-paste this whole function, of course!


# Problem 4

*Play around with the group model. Create matrices with more than 3 groups, for
example.*

```{r}
generate_group_model <- function(groups, P, S){
  M <- matrix(rbinom(S^2, size = 1, prob = P[groups, groups]), S, S)
  M <- M[order(groups), order(groups)]
  return(M)
}

S <- 20
groups <- rbinom(S, size=4, 0.5)
m <- max(groups)
P <- matrix(runif((m + 1)^2), m + 1, m + 1)

M <- generate_group_model(groups, P, S)
groups <- groups[order(groups)] + 1 # Now this is needed, for the plotting,

## Make a plot by groups
Mplot <- tbl_df(melt(t(M))) %>%
  mutate(Var2 = S - Var2 + 1,
         group1 = groups[Var1],
         group2 = groups[Var2],
         tag = (group1-1)*(m + 1) + group2)

Mplot %>% ggplot(aes(x = Var1, y = Var2, fill = as.character(tag))) +
  geom_tile(alpha = 0.6) + theme_bw() +
  geom_point(size = 5, alpha = 0.5,
             aes(fill = as.factor(value), colour = as.factor(value))) +
  scale_colour_manual(values = c("white", "black")) +
  theme(legend.position = "none")
```


# Problem 5

*Compare generative models for a different network. That can be another food
web (such as Chesapeake) or any other network. But, if you do not use a food
web you should come up with generative model that make sense for your system!*


# Problem 6 (optional)

Devise a code that maximizes the likelihood by also searching for the correct
species order.


# Problem 7 (optional)

Generating networks can be used to test, for example, hypotheses regarding the
consequences of structure. For example, we can ask if networks generated with
the niche model are more robust than those generated using an Erdos-Reyni
process. One exercise would be to generate a distribution of networks of a
given size and connectance using different models and test their robustness.
Try to do develop that code. You can also try to test if robustness is affected
by the interaction between size, connectance and the different models (i.e., if
different models produce more robust networks for a given range of $S$ or $C$)
